pipeline {
    agent {
        node {
            label 'docker'
        }
    }

    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timeout(time: 30, unit: 'MINUTES')
        skipStagesAfterUnstable()
        parallelsAlwaysFailFast()
        disableConcurrentBuilds()
    }

    environment {
        // Registry and Infrastructure Configuration
        REGISTRY_URL = "icr.io/etl-registry"
        REGION = "us-south"
        CLUSTER_NAME = "etl-cluster"
        RESOURCE_GROUP = "ETL-rg"

        // Build Configuration
        IMAGE_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT?.take(7) ?: 'unknown'}"
        BUILD_TIMESTAMP = sh(script: 'date +%Y%m%d-%H%M%S', returnStdout: true).trim()

        // Branch-specific Configuration
        TARGET_NAMESPACE = getTargetNamespace()
        IS_PRODUCTION = "${env.BRANCH_NAME == 'master' ? 'true' : 'false'}"
        IS_DEPLOY_BRANCH = isDeployableBranch()

        // Service Configuration
        SERVICES = "extract,transform,load,scheduler,visualization"
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    // Display build information
                    echo """
                    ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
                    ‚ïë                    PSX ETL Pipeline Build                     ‚ïë
                    ‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
                    ‚ïë Branch:           ${env.BRANCH_NAME}
                    ‚ïë Target Namespace: ${env.TARGET_NAMESPACE}
                    ‚ïë Image Tag:        ${env.IMAGE_TAG}
                    ‚ïë Build Number:     ${env.BUILD_NUMBER}
                    ‚ïë Commit:           ${env.GIT_COMMIT?.take(7) ?: 'N/A'}
                    ‚ïë Is Production:    ${env.IS_PRODUCTION}
                    ‚ïë Timestamp:        ${env.BUILD_TIMESTAMP}
                    ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
                    """

                    // Validate branch
                    if (env.IS_DEPLOY_BRANCH == 'false') {
                        currentBuild.result = 'NOT_BUILT'
                        echo "‚ö†Ô∏è  Branch '${env.BRANCH_NAME}' is not configured for deployment. Skipping pipeline."
                        return
                    }

                    // Set build description
                    currentBuild.description = "Branch: ${env.BRANCH_NAME} | Namespace: ${env.TARGET_NAMESPACE}"
                    currentBuild.displayName = "#${env.BUILD_NUMBER}-${env.BRANCH_NAME}"
                }
            }
        }

        stage('Checkout & Validation') {
            when {
                expression { env.IS_DEPLOY_BRANCH == 'true' }
            }
            steps {
                script {
                    // Clean workspace
                    cleanWs()

                    // Checkout source code
                    checkout scm

                    // Validate required files exist
                    def requiredPaths = [
                        './psx-etl/services/extract/Dockerfile',
                        './psx-etl/services/transform/Dockerfile',
                        './psx-etl/services/load/Dockerfile',
                        './psx-etl/services/scheduler/Dockerfile',
                        './psx-etl/services/visualization/Dockerfile',
                        './psx-etl/infra/k8s/services/',
                        './psx-etl/infra/k8s/database/'
                    ]

                    requiredPaths.each { path ->
                        if (!fileExists(path)) {
                            error "‚ùå Required path not found: ${path}"
                        }
                    }

                    echo "‚úÖ All required files validated successfully"
                }
            }
        }

        stage('IBM Cloud Authentication') {
            when {
                expression { env.IS_DEPLOY_BRANCH == 'true' }
            }
            steps {
                script {
                    withCredentials([string(credentialsId: 'ibm-cloud-api-key', variable: 'IBM_CLOUD_API_KEY')]) {
                        try {
                            sh '''
                                echo "üîê Authenticating with IBM Cloud..."

                                # Login to IBM Cloud
                                ibmcloud login --apikey $IBM_CLOUD_API_KEY -r $REGION --quiet

                                # Target resource group
                                ibmcloud target -g $RESOURCE_GROUP --quiet

                                # Login to Container Registry
                                ibmcloud cr login

                                # Configure kubectl for cluster
                                ibmcloud ks cluster config --cluster $CLUSTER_NAME

                                # Verify cluster connection
                                kubectl cluster-info --request-timeout=10s

                                echo "‚úÖ IBM Cloud authentication successful"
                            '''
                        } catch (Exception e) {
                            error "‚ùå IBM Cloud authentication failed: ${e.getMessage()}"
                        }
                    }
                }
            }
        }

        stage('Build & Push Container Images') {
            when {
                expression { env.IS_DEPLOY_BRANCH == 'true' }
            }
            steps {
                script {
                    def services = env.SERVICES.split(',')
                    def parallelBuilds = [:]

                    services.each { service ->
                        parallelBuilds[service.capitalize()] = {
                            node('docker') {
                                try {
                                    echo "üèóÔ∏è  Building ${service} service..."

                                    checkout scm

                                    def imageName = "${env.REGISTRY_URL}/psx-etl-${service}:${env.IMAGE_TAG}"
                                    def serviceDir = "./psx-etl/services/${service}"

                                    // Verify Dockerfile exists
                                    if (!fileExists("${serviceDir}/Dockerfile")) {
                                        error "‚ùå Dockerfile not found for service: ${service}"
                                    }

                                    // Build and push image
                                    def image = docker.build(imageName, serviceDir)
                                    image.push()
                                    image.push("${service}-latest")  // Also tag as latest

                                    echo "‚úÖ Successfully built and pushed: ${imageName}"

                                } catch (Exception e) {
                                    error "‚ùå Failed to build ${service}: ${e.getMessage()}"
                                } finally {
                                    // Clean up Docker images on node
                                    sh "docker system prune -f --filter until=24h || true"
                                }
                            }
                        }
                    }

                    // Execute parallel builds
                    parallel parallelBuilds
                    echo "‚úÖ All container images built and pushed successfully"
                }
            }
        }

        stage('Security Scan') {
            when {
                expression { env.IS_DEPLOY_BRANCH == 'true' }
            }
            steps {
                script {
                    if (env.IS_PRODUCTION == 'true') {
                        echo "üîç Running security scan for production deployment..."
                        // Add your security scanning tools here
                        // Example: Trivy, Snyk, or IBM Cloud Security Advisor
                        sh '''
                            echo "Security scan placeholder - integrate your preferred scanner"
                            # trivy image ${REGISTRY_URL}/psx-etl-extract:${IMAGE_TAG} || true
                        '''
                    } else {
                        echo "‚ÑπÔ∏è  Skipping security scan for non-production deployment"
                    }
                }
            }
        }

        stage('Production Deployment Approval') {
            when {
                expression { env.IS_PRODUCTION == 'true' }
            }
            steps {
                script {
                    try {
                        echo "‚è≥ Requesting production deployment approval..."

                        def approvalMessage = """
                        üöÄ Production Deployment Request

                        Branch: ${env.BRANCH_NAME}
                        Build: ${env.BUILD_NUMBER}
                        Commit: ${env.GIT_COMMIT?.take(7)}
                        Image Tag: ${env.IMAGE_TAG}
                        Timestamp: ${env.BUILD_TIMESTAMP}

                        Services to deploy: ${env.SERVICES.replace(',', ', ')}
                        Target Namespace: ${env.TARGET_NAMESPACE}
                        """

                        timeout(time: 15, unit: 'MINUTES') {
                            def approval = input(
                                message: approvalMessage,
                                ok: 'üöÄ Deploy to Production',
                                parameters: [
                                    choice(
                                        name: 'DEPLOYMENT_TYPE',
                                        choices: ['rolling-update', 'blue-green'],
                                        description: 'Select deployment strategy'
                                    ),
                                    booleanParam(
                                        name: 'RUN_SMOKE_TESTS',
                                        defaultValue: true,
                                        description: 'Run smoke tests after deployment'
                                    )
                                ],
                                submitterParameter: 'APPROVER'
                            )

                            env.DEPLOYMENT_TYPE = approval.DEPLOYMENT_TYPE
                            env.RUN_SMOKE_TESTS = approval.RUN_SMOKE_TESTS.toString()

                            echo "‚úÖ Production deployment approved by: ${env.APPROVER}"
                            echo "üìã Deployment type: ${env.DEPLOYMENT_TYPE}"
                        }

                    } catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException e) {
                        echo "‚ùå Production deployment approval timeout or cancelled"
                        currentBuild.result = 'ABORTED'
                        error "Production deployment cancelled - no approval received"
                    }
                }
            }
        }

        stage('Pre-deployment Checks') {
            when {
                expression { env.IS_DEPLOY_BRANCH == 'true' }
            }
            steps {
                script {
                    echo "üîç Running pre-deployment checks..."

                    sh '''
                        # Verify namespace exists
                        kubectl get namespace ${TARGET_NAMESPACE} || kubectl create namespace ${TARGET_NAMESPACE}

                        # Verify database namespace exists
                        kubectl get namespace database || kubectl create namespace database

                        # Check cluster resources
                        kubectl top nodes --no-headers | head -5 || echo "Node metrics not available"

                        # Verify registry connectivity
                        ibmcloud cr images --restrict ${REGISTRY_URL} --limit 1 > /dev/null

                        echo "‚úÖ Pre-deployment checks completed"
                    '''
                }
            }
        }

        stage('Deploy to Kubernetes') {
            when {
                expression { env.IS_DEPLOY_BRANCH == 'true' }
            }
            steps {
                script {
                    try {
                        echo "üöÄ Starting deployment to ${env.TARGET_NAMESPACE} namespace..."

                        sh '''
                            # Create backup of current deployment (production only)
                            if [ "${IS_PRODUCTION}" = "true" ]; then
                                echo "üì¶ Creating backup of current production deployment..."
                                kubectl get deployments -n ${TARGET_NAMESPACE} -o yaml > deployment-backup-${BUILD_NUMBER}.yaml || echo "No existing deployments to backup"
                            fi

                            # Replace placeholders in deployment files
                            echo "üîÑ Updating deployment manifests..."
                            find ./psx-etl/infra/k8s/services -type f -name '*.yaml' -exec sed -i "s|__IMAGE_TAG__|${IMAGE_TAG}|g" {} +
                            find ./psx-etl/infra/k8s/services -type f -name '*.yaml' -exec sed -i "s|__NAMESPACE__|${TARGET_NAMESPACE}|g" {} +
                            find ./psx-etl/infra/k8s/services -type f -name '*.yaml' -exec sed -i "s|__BUILD_NUMBER__|${BUILD_NUMBER}|g" {} +

                            # Deploy database components (shared across environments)
                            echo "üóÑÔ∏è  Deploying database components..."
                            kubectl apply --namespace=database -R -f psx-etl/infra/k8s/database/ --record

                            # Deploy application services
                            echo "üì¶ Deploying application services to ${TARGET_NAMESPACE}..."
                            kubectl apply -n ${TARGET_NAMESPACE} -R -f psx-etl/infra/k8s/services/ --record

                            # Deploy ingress
                            echo "üåê Deploying ingress configuration..."
                            kubectl apply -n ${TARGET_NAMESPACE} -f psx-etl/infra/k8s/ingress.yaml --record

                            # Wait for deployments to be ready
                            echo "‚è≥ Waiting for deployments to be ready..."
                            kubectl wait --for=condition=available --timeout=300s deployment --all -n ${TARGET_NAMESPACE}

                            # Display deployment status
                            echo "üìä Deployment status:"
                            kubectl get pods,services,ingress -n ${TARGET_NAMESPACE}
                        '''

                        echo "‚úÖ Deployment to ${env.TARGET_NAMESPACE} completed successfully!"

                    } catch (Exception e) {
                        echo "‚ùå Deployment failed: ${e.getMessage()}"

                        // Rollback for production failures
                        if (env.IS_PRODUCTION == 'true') {
                            echo "üîÑ Initiating rollback for production..."
                            sh '''
                                if [ -f "deployment-backup-${BUILD_NUMBER}.yaml" ]; then
                                    echo "üì¶ Rolling back to previous deployment..."
                                    kubectl apply -f deployment-backup-${BUILD_NUMBER}.yaml
                                else
                                    echo "‚ö†Ô∏è  No backup found, manual intervention may be required"
                                fi
                            '''
                        }

                        throw e
                    }
                }
            }
        }

        stage('Post-deployment Validation') {
            when {
                expression { env.IS_DEPLOY_BRANCH == 'true' }
            }
            steps {
                script {
                    echo "üß™ Running post-deployment validation..."

                    sh '''
                        # Health check for all services
                        echo "üè• Checking service health..."

                        # Wait a bit for services to stabilize
                        sleep 30

                        # Check pod status
                        FAILED_PODS=$(kubectl get pods -n ${TARGET_NAMESPACE} --field-selector=status.phase!=Running --no-headers | wc -l)

                        if [ $FAILED_PODS -gt 0 ]; then
                            echo "‚ùå Found ${FAILED_PODS} failed pods:"
                            kubectl get pods -n ${TARGET_NAMESPACE} --field-selector=status.phase!=Running
                            kubectl describe pods -n ${TARGET_NAMESPACE} --field-selector=status.phase!=Running
                            exit 1
                        fi

                        echo "‚úÖ All pods are running successfully"

                        # Display final status
                        kubectl get all -n ${TARGET_NAMESPACE}
                    '''

                    // Run smoke tests for production
                    if (env.IS_PRODUCTION == 'true' && env.RUN_SMOKE_TESTS == 'true') {
                        echo "üß™ Running production smoke tests..."
                        sh '''
                            # Add your smoke tests here
                            echo "Smoke test placeholder - add your API health checks"
                            # curl -f http://your-service/health || exit 1
                        '''
                    }

                    echo "‚úÖ Post-deployment validation completed successfully"
                }
            }
        }
    }

    post {
        always {
            script {
                // Archive important files
                if (env.IS_DEPLOY_BRANCH == 'true') {
                    archiveArtifacts artifacts: 'deployment-backup-*.yaml', allowEmptyArchive: true
                }

                echo "üßπ Cleaning up workspace..."
                cleanWs()
            }
        }

        success {
            script {
                if (env.IS_DEPLOY_BRANCH == 'true') {
                    def successMessage = """
                    ‚úÖ **PSX ETL Deployment Successful**

                    üìã **Details:**
                    ‚Ä¢ Branch: `${env.BRANCH_NAME}`
                    ‚Ä¢ Namespace: `${env.TARGET_NAMESPACE}`
                    ‚Ä¢ Build: `${env.BUILD_NUMBER}`
                    ‚Ä¢ Image Tag: `${env.IMAGE_TAG}`
                    ‚Ä¢ Commit: `${env.GIT_COMMIT?.take(7)}`
                    ‚Ä¢ Duration: ${currentBuild.durationString}

                    ${
                        env.IS_PRODUCTION == 'true'
                            ? 'üöÄ **Production deployment completed!**'
                            : 'üîß **Development deployment completed!**'
                    }
                    """

                    echo successMessage

                    // Add Slack/Teams notification here if needed
                    // slackSend(message: successMessage, color: 'good')
                }
            }
        }

        failure {
            script {
                if (env.IS_DEPLOY_BRANCH == 'true') {
                    def failureMessage = """
                    ‚ùå **PSX ETL Deployment Failed**

                    üìã **Details:**
                    ‚Ä¢ Branch: `${env.BRANCH_NAME}`
                    ‚Ä¢ Namespace: `${env.TARGET_NAMESPACE}`
                    ‚Ä¢ Build: `${env.BUILD_NUMBER}`
                    ‚Ä¢ Failed Stage: `${env.STAGE_NAME ?: 'Unknown'}`
                    ‚Ä¢ Duration: ${currentBuild.durationString}

                    üîó **Build URL:** ${env.BUILD_URL}
                    """

                    echo failureMessage

                    // Add alerting here if needed
                    // slackSend(message: failureMessage, color: 'danger')
                }
            }
        }

        aborted {
            script {
                echo "‚èπÔ∏è  **Pipeline Aborted** - Branch: ${env.BRANCH_NAME}, Build: ${env.BUILD_NUMBER}"
            }
        }

        unstable {
            script {
                echo "‚ö†Ô∏è  **Pipeline Unstable** - Branch: ${env.BRANCH_NAME}, Build: ${env.BUILD_NUMBER}"
            }
        }
    }
}

// Helper Functions
def getTargetNamespace() {
    switch (env.BRANCH_NAME) {
        case 'master':
            return 'prod'
        case 'dev':
        case 'qa-test':
            return 'dev'
        default:
            return 'dev'  // Default fallback
    }
}

def isDeployableBranch() {
    def allowedBranches = ['dev', 'qa-test', 'master']
    return allowedBranches.contains(env.BRANCH_NAME) ? 'true' : 'false'
}
